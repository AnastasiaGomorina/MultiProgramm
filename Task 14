#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

// Определение пользовательского семафора
class Semaphore {
public:
    // Конструктор инициализирует счетчик семафора
    explicit Semaphore(int count = 0) : count(count) {}

    // Метод для увеличения счетчика и уведомления одного из ожидающих потоков
    void signal() {
        std::unique_lock<std::mutex> lock(mtx); // Захват мьютекса
        ++count;                                // Увеличение счетчика
        cv.notify_one();                        // Уведомление одного из ожидающих потоков
    }

    // Метод для уменьшения счетчика и ожидания, если счетчик равен нулю
    void wait() {
        std::unique_lock<std::mutex> lock(mtx); // Захват мьютекса
        cv.wait(lock, [this] { return count > 0; }); // Ожидание, пока счетчик не станет больше нуля
        --count;                                // Уменьшение счетчика
    }

private:
    std::mutex mtx;                // Мьютекс для защиты доступа к счетчику
    std::condition_variable cv;    // Условная переменная для ожидания и уведомления
    int count;                     // Счетчик семафора
};

// Объявление семафоров
Semaphore parent_sem(1);  // Семафор родительского потока, инициализируется единицей, чтобы начать с родительского потока
Semaphore child_sem(0);   // Семафор дочернего потока, инициализируется нулем, чтобы начать с ожидания

// Функция для вывода сообщений в родительском потоке
void print_parent() {
    for (int i = 0; i < 10; ++i) {
        parent_sem.wait();  // Ожидание сигнала от дочернего потока
        std::cout << "Сообщение из родительского потока " << i + 1 << std::endl;
        child_sem.signal();  // Сигнал дочернему потоку, чтобы он мог продолжить выполнение
    }
}

// Функция для вывода сообщений в дочернем потоке
void print_child() {
    for (int i = 0; i < 10; ++i) {
        child_sem.wait();  // Ожидание сигнала от родительского потока
        std::cout << "Сообщение из дочернего потока " << i + 1 << std::endl;
        parent_sem.signal();  // Сигнал родительскому потоку, чтобы он мог продолжить выполнение
    }
}

int main() {
    setlocale(LC_ALL, "Ru");
    // Создание потоков
    std::thread parent(print_parent); // Создание потока для выполнения функции print_parent
    std::thread child(print_child);   // Создание потока для выполнения функции print_child

    // Ожидание завершения потоков
    parent.join(); // Ожидание завершения выполнения родительского потока
    child.join();  // Ожидание завершения выполнения дочернего потока

    return 0; // Завершение программы
}
